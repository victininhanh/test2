exports.unpack = function(msg, packager) {
	
	var chunk = msg;
	var chunkBin, data = '', bitmap = '';
	
	do {
		chunk = msg.substring(0, packager.length); // Get to length
		//chunkBitmap = parseInt(chunk, 16).toString(2); // Convert to bit
    chunkBitmap = hex2bin(chunk);
		while (chunkBitmap.length < (packager.length * 4)) {
			chunkBitmap = '0' + chunkBitmap;
		}
		data += chunk;
		bitmap += chunkBitmap;
		msg = msg.substr(packager.length);
	} while(chunkBitmap[0] > 0);
	
	var fieldIds = [];
	for(var i in bitmap) {
		if (i > 0 && bitmap[i] == 1) {
			fieldIds.push(parseInt(i) + 1);
		}
	}
	
	//console.log(data);
	//console.log(bitmap);
	console.log("Unpack b" + require('util').inspect({
    fieldIds:fieldIds,
		data: data,
		bitmap: bitmap,
		fieldIds: fieldIds,
		restData: msg
	}) );
	return {
		data: data,
		bitmap: bitmap,
		fieldIds: fieldIds,
		restData: msg
	};
};

exports.pack = function(data, packager) {
	
  var bitmap = '';
	var lastIndex = 0; // danh dau da xu ly xong MII co ID nao (xu ly bat bit nao)
  console.log('PACK b starting');
	for (var i in data) { // i la ID dang xu ly
		if (i > 1) {
      console.log('i > 1, i = ', i);
			var offset = i - lastIndex - 1;
      console.log('offset  ',offset, ' i = ',i, 'i - lastIndex - 1 =  ', i - lastIndex - 1);
			for(var j = 0; j < offset; j++) {
				bitmap += '0';
        console.log('for j :', j , ' to < offset ',offset, ' bitmap = ', bitmap);
			}
			bitmap += '1';
			lastIndex = i;
        console.log('end of for var i bitmap', i , 'bitmap = ', bitmap, 'lastIndex = ',lastIndex);
		}
	}
	console.log("lastIndex, offset, bitmap", lastIndex, offset, bitmap );
	var length = Math.ceil(bitmap.length / (packager.length * 4)) * (packager.length * 4);
	var blength = bitmap.length;
	for(var i = 0; i < length - blength; i++) {
		bitmap += '0';
	}
	console.log('length, blength,  bitmap',length, blength,  bitmap );
  
	//var msg = parseInt(bitmap,2).toString(16).toUpperCase();
  //var msg = bin2Hex(bitmap).result.toUpperCase();
	//console.log('msg',msg);
  //console.log('bitmap',bitmap);
	//console.log(msg);
	//console.log(bitmap);
	
  //Check 128 bit
  console.log('Check if fix bitmap, length = ', bitmap.length);
  if (bitmap.length > 64)
  {
    console.log('Fix bitmap');
    bitmap= '1' + bitmap.substr(1,bitmap.length);    
    console.log("New bitmap = ", bitmap);            
  }
	
  var msg = bin2Hex(bitmap).result.toUpperCase();
	console.log('msg',msg);
  console.log('bitmap',bitmap);
  
	console.log("Pack b" + require('util').inspect({
    data: data,
		msg: msg,
		bitmap: bitmap
	}));
	return {
		msg: msg,
		bitmap: bitmap
	};
};
// ------- Convert ---------------
function int2bin(n){
  return parseInt(n,10).toString(2);
}

function hex2bytes(hex)
{
    var bytes = [], str;

    for(var i=0; i< hex.length-1; i+=2)
        bytes.push(parseInt(hex.substr(i, 2), 16));
   
   
    //return String.fromCharCode.apply(String, bytes);    
  return bytes;
}

function pad(num, size){     
    return ('0000000000' + num).substr(-size); 
}
function hex2bin(h){
  //var h = 'F66064810870A0120000000000000004';
  var bytes = hex2bytes(h);
  var m='',i,tmp =[];
  for (i=0; i<bytes.length; i++){
    m+=pad(int2bin(bytes[i]),8); // thieu so
       
  }
  return m;
  
}


// Bin 2 hex
      function bin2Hex(s) {
        var i, k, part, accum, ret = '';
        for (i = s.length-1; i >= 3; i -= 4) {
            // extract out in substrings of 4 and convert to hex
            part = s.substr(i+1-4, 4);
            accum = 0;
            for (k = 0; k < 4; k += 1) {
                if (part[k] !== '0' && part[k] !== '1') {
                    // invalid character
                    return { valid: false };
                }
                // compute the length 4 substring
                accum = accum * 2 + parseInt(part[k], 10);
            }
            if (accum >= 10) {
                // 'A' to 'F'
                ret = String.fromCharCode(accum - 10 + 'A'.charCodeAt(0)) + ret;
            } else {
                // '0' to '9'
                ret = String(accum) + ret;
            }
        }
        // remaining characters, i = 0, 1, or 2
        if (i >= 0) {
            accum = 0;
            // convert from front
            for (k = 0; k <= i; k += 1) {
                if (s[k] !== '0' && s[k] !== '1') {
                    return { valid: false };
                }
                accum = accum * 2 + parseInt(s[k], 10);
            }
            // 3 bits, value cannot exceed 2^3 - 1 = 7, just convert
            ret = String(accum) + ret;
        }
        return { valid: true, result: ret };
    }

  //